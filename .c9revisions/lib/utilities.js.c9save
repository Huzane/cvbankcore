{"ts":1380283518761,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n* @module lib\n* */\n\n/**\n* @class utilities\n* */\n\nvar util = require('util');\n\n/**\n* Checks where required properties are set\n* @method requireProperties\n* @param names {Array} the array of properties to check for\n* @param errorMessageFormat {String} [optional] a string to format the error message with\n* */\nmodule.exports.requireProperties = function(object, names, errorMessageFormat) {\n\tif (errorMessageFormat === undefined) {\n\t\terrorMessageFormat = '%s is undefined';\n\t}\n\tvar errors = '';\n\tvar hasError = false;\n\tfor (var j = names.length - 1; j >= 0; j--) {\n\t\tvar n = names[j];\n\n\t\tif (object[n] === undefined) {\n\t\t\tif (hasError) {\n\t\t\t\terrors += ', ';\n\t\t\t}\n\t\t\thasError = true;\n\t\t\terrors += (util.format(errorMessageFormat, n));\n\t\t}\n\t}\n\tif (hasError) {\n\t\tthrow new Error(errors);\n\t}\n};\n/**\n* */\nfunction clonePropertyImpl(obj, newName, existingProperty, deleteExisting) {\n\t//If newName property already exists don't touch it\n\tvar _ = require(\"underscore\");\n\t//obj = _.extend({}, obj);\n\n\tif (obj[newName]) {\n\t\tif (deleteExisting === true) {\n\t\t\tdelete obj[existingProperty];\n\t\t}\n\t\treturn obj;\n\t}\n\t//If the existing property is undefined then do nothing\n\tif (obj[existingProperty] === undefined) {\n\n\t\treturn obj;\n\t}\n\n\tobj[newName] = obj[existingProperty];\n\n\tif (deleteExisting === true) {\n\t\tdelete obj[existingProperty];\n\t}\n\treturn obj;\n}\n\n/**\n* Looks thru the named properties of an object and convert them to ObjectId\n* @method convertToObjectId\n* @param obj {Object} the object having properties to convert\n* @param parameter {String, List} properties to convert\n* @return the object whose properties have been converted\n* \n* E.g convertToObjectId(req.body/req.query, 'campaignID', 'companyID')\n* */\nmodule.exports.convertToObjectId = function() {\n\tvar mongoose = require(\"mongoose\");\n\tvar obj = arguments[0];\n\tfor (var j = 1; j < arguments.length; j++) {\n\t\tvar a = arguments[j];\n\t\tif (obj[a]) {\n\t\t\tobj[a] = mongoose.Types.ObjectId(obj[a]);\n\t\t}\n\t}\n\treturn obj;\n};\n\n/**\n* Creates an array from the property of an object/objects\n*\n* @deprecated This method is supposed to take care of what underscore _.pluck already does (and perharps more optimized)\n* @method getPropertyArray\n* @param source {Object/Array} the object having properties to get\n* @param property {String, Function} name of the property or a function to get the property\n* @return an array in which the elements are made up of [object.property]\n* \n* E.g convertToObjectId(req.body, 'campaignID', 'companyID')\n* */\nmodule.exports.getPropertyArray = function(source, property) {\n\tvar _ = require(\"underscore\");\n\tvar fn = function(obj) {\n\t\tif (property instanceof Function) {\n\t\t\treturn property(obj);\n\t\t}\n\t\treturn obj[property];\n\t};\n\n\tvar ret = [];\n\tif (source instanceof Array) {\n\t\t_.each(source, function(s) {\n\t\t\tvar v = fn(s);\n\t\t\tif (v) {\n\t\t\t\tret.push(v);\n\t\t\t}\n\t\t});\n\t}\n\telse {\n\t\tvar v = fn(source);\n\t\tif (v) {\n\t\t\tret.push(v);\n\t\t}\n\t}\n\treturn ret;\n};\n\n/**\n* For the cases where a property of a given name is already used on views but it otherwise exists as a different property\n* This method will add the property desired to the object and uses the existing property as its value\n* \n* Instance\n* A lot has already been written as Model#campaignID but campaignID can be populated and on views what is being used is object#campaign\n* This function can be used to add a 'campaign' property using 'campaignID'.\n* \n* @method cloneProperty\n* @param obj {Object, Array} the object or array of objects whose property should be cloned\n* @param newName {String} the new property that should be a close on existing property\n* @param existingProperty {String} the existing property that should be cloned\n* @param deleteExisting {Boolean} [optional] if true then the existing property is deleted (as if the old property is renamed)\n* @return {Object, Array} object / objects having 'newName' property whose value is same as 'existingProperty'\n* */\nmodule.exports.cloneProperty = function(obj, newName, existingProperty, deleteExisting) {\n\tvar _ = require(\"underscore\");\n\n\tif (util.isArray(obj)) {\n\t\t//var results = [];\n\t\t_.each(obj, function(o) {\n\t\t\tclonePropertyImpl(o, newName, existingProperty, deleteExisting);\n\t\t\t//results.push(clonePropertyImpl(o, newName, existingProperty, deleteExisting));\n\t\t});\n\t\t//obj = results;\n\t}\n\telse {\n\t\tobj = clonePropertyImpl(obj, newName, existingProperty, deleteExisting);\n\t}\n\treturn obj;\n};\n\n/**\n* @deprecated\n* Looks for standard query function names in the options and automatically call them with the value of the property\n* @method callQueryFunctions\n* @param query {Query} mongoose query object\n* @param options {Object} the object having the properties to apply\n* @param propertyNames {Array} an array of properties to restrict to\n* @param santizeCallback {Function} a callback function that allows the property value be sanitized before being used by the query object\n* */\nmodule.exports.callQueryFunctions = function(query, options, propertyNames, santizeCallback) {\n\t//var _ = require(\"underscore\");\n\t// for (var p in options) {\n\t// if (propertyNames && _.indexOf(propertyNames, p) !== -1) {\n\t// continue;\n\t// }\n\t// if (query[p] && query[p] instanceof Function) {\n\t// var v = options[p];\n\t// if (santizeCallback) {\n\t// v = santizeCallback(p, v);\n\t// }\n\t// query[p](v);\n\t// }\n\t// }\n\t\n\tthrow new Error('This method is deprecated');\n\t\n\t// console.log(query);\n\t\n\t// if (options.limit) {\n\t// query.limit(limit);\n\t// }\n\t// if (options.skip) {\n\t// query.skip(skip);\n\t// }\n\t// if (options.sort) {\n\t// query.sort(sort);\n\t// }\n\t// return query;\n};\n\nmodule.exports.genPassword = function() {\n\tvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\n\tvar string_length = 8;\n\tvar randomstring = '';\n\tvar charCount = 0;\n\tvar numCount = 0;\n\tvar rnum;\n\n\tfor (var i = 0; i < string_length; i++) {\n\t\t// If random bit is 0, there are less than 3 digits already saved, and there are not already 5 characters saved, generate a numeric value. \n\t\tif ((Math.floor(Math.random() * 2) === 0) && numCount < 3 || charCount >= 5) {\n\t\t\trnum = Math.floor(Math.random() * 10);\n\t\t\trandomstring += rnum;\n\t\t\tnumCount += 1;\n\t\t}\n\t\telse {\n\t\t\t// If any of the above criteria fail, go ahead and generate an alpha character from the chars string\n\t\t\trnum = Math.floor(Math.random() * chars.length);\n\t\t\trandomstring += chars.substring(rnum, rnum + 1);\n\t\t\tcharCount += 1;\n\t\t}\n\t}\n\treturn randomstring;\n};\n\n\nvar BASE_ALPHA = 'abcdefghijklmnopqrstuvwxyz_';\nvar BASE_ALPHA_NUM = 'abcdefghijklmnopqrstuvwxyz_0123456789';\nvar BASE_NUM = '0123456789';\n/**\n* Generates a random string\n* @method randomString\n* @param baseType {String} 'alpha', 'num', 'alpha_num'. Default is 'alpha'\n* @param length {Number} the length of the string. Default is 6\n* */\nmodule.exports.randomString = function() {\n\tvar base = 'alpha', length = 6;\n\tif (arguments.length === 2) {\n\t\tbase = arguments[0].toLowerCase();\n\t\tlength = arguments[1];\n\t}else if (arguments.length === 1) {\n\t\tvar a = arguments[0];\n\t\tif ('number' === typeof a) {\n\t\t\tlength = a;\n\t\t}else {\n\t\t\tbase = a.toLowerCase();\n\t\t}\n\t}\n\t\n\tvar baseString = BASE_ALPHA;\n\tswitch (base) {\n\tcase 'alpha':\n\tcase 'alphabet':\n\tcase 'letters':\n\tcase 'letter':\n\t\tbaseString = BASE_ALPHA;\n\t\tbreak;\n\tcase 'digit':\n\tcase 'digits':\n\tcase 'num':\n\tcase 'number':\n\t\tbaseString = BASE_NUM;\n\t\tbreak;\n\tcase 'alpha_num':\n\tcase 'alpha_number':\n\t\tbaseString = BASE_ALPHA_NUM;        \n\t\tbreak;\n\t}\n\t\n\tvar str = '';\n\tvar len = baseString.length;\n\tfor (var j = 0; j < length; j++) {\n\t\tvar idx = Math.floor(Math.random() * len);\n\t\t\n\t\tif (idx === len) {\n\t\t\tidx = 0;\n\t\t}\n\t\tstr += baseString.substr(idx, 1);\n\t}\n\treturn str;\n};"]],"start1":0,"start2":0,"length1":0,"length2":7595}]],"length":7595}
